import {  retry } from 'rxjs/operators';
import { NgxSpinnerService } from 'ngx-spinner';
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpErrorResponse, HttpParams,HttpBackend } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { UtilService } from './util.service';
import { AppSettings } from './AppSettings';
import { catchError } from 'rxjs/internal/operators/catchError';
import { CommonValues } from './commonValues';
import Swal from 'sweetalert2';



if (localStorage.getItem('userId') == null || localStorage.getItem('userId') == '') {
  const id = '';
} else {
  const id = localStorage.getItem('userId');
}

// const httpOptions = {
//   headers: new HttpHeaders({
//     'Content-Type': AppSettings.HTTP_CONTENT_TYPE,
//     'Access-Control-Allow-Origin': AppSettings.HTTP_ACCESS_CONTROL_ALLOW_ORIGIN,
//     //'userId': id
//   })
// };

const commonHeader = {
  headers: new HttpHeaders({
    'Content-Type' : 'application/x-www-form-urlencoded; charset=UTF-8',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods':'*',
    "Access-Control-Allow-Headers":"Origin, X-Requested-ith, Content-Type, Accept, Authorization"
  })
};
@Injectable({
  providedIn: 'root'
})

export class ApiService {
  // errorCount: number;
  private byPassCall :HttpClient
  constructor(
    private http: HttpClient,private util: UtilService,private commonvalues: CommonValues,private spinner: NgxSpinnerService,private byPassReq : HttpBackend) {
            this.byPassCall = new HttpClient(byPassReq)
    }

  startLoader() {
    this.spinner.show();
  }

  stopLoader() {
    this.spinner.hide();
  }
  login(u, User): Observable<any> {
    const url = AppSettings.ServerUrl + u;
    return this.http.post<any>(url , User).pipe(
      retry(2),
      // return this.http.post<any>(url , User , commonHeader).pipe(
      catchError(this.handleError1));
  }

create(u, User,errorMessage?: string): Observable<any> {
  const url = AppSettings.ServerUrl + u;
  return this.http.post<any>(url,User).pipe(
    catchError(this.handleError<any>(errorMessage))
  )
}


query(u:string,errorMessage?: string): Observable<any> {
  const url = AppSettings.ServerUrl + u;
  // if(adData.loaderAnderror){
    return this.http.get<any>(url).pipe(
      catchError(this.handleError<any>(errorMessage)));
  // }else{
  //   return this.byPassCall.get<any>(url).pipe(
  //     );
  // }

}

queryPassval(u,data,errorMessage?: string): Observable<any> {
  const url = AppSettings.ServerUrl + u;
  return this.http.get<any>(url , data).pipe(
    catchError(this.handleError<any>(errorMessage))
    );
}



updatePut(u,secData,errorMessage?: string){
  const url = AppSettings.ServerUrl + u;
  return this.http.put<any>(url, secData).pipe(
    catchError(this.handleError<any>(errorMessage))
  );
}



delete(data,errorMessage?: string) {
  const url = AppSettings.ServerUrl+data;
  return this.http.delete<any>(url,data).pipe(
    catchError(this.handleError<any>(errorMessage))
  );
}



AuthToken(u , auth): Observable<any> {
  const url = AppSettings.ServerUrl + u;
  return this.http.get<any>(url , auth);
}

AuthValidation(u , vaildation): Observable<any> {
  const url = AppSettings.ServerUrl + u ;
  return this.http.post<any>(url , vaildation).pipe(
    // return this.http.post<any>(url , vaildation , commonHeader).pipe(
    catchError(this.handleError<any>('Token Validation Check'))
  );
}


onLogout() {
  const url = AppSettings.ServerUrl + 'home/logout';
  return this.http.post<any>(url, {}).pipe(
    catchError(this.handleError<any>('communityDetails'))
  );
}


logout(){
// const url = AppSettings.ServerUrl + "sso/logout";
  let url =AppSettings.ServerUrl + "sso/logout?redirect_url="+window.location.href;
  // //// console.log("url---- "+url);
  window.location.href=url;
   //  return this.http.get<any>(url).pipe(
  // );
}
 // Message page services
  messagePageService(method: string, path: string, data?: any, upload?: any, operation?: any) {
    const url = AppSettings.ServerUrl + path;
    if (method === 'GET') {
      return this.http.get(url,data).pipe(catchError(this.handleError<any>(operation)));
    } else if (method === 'POST') {
      return this.http.post(url, data).pipe(catchError(this.handleError<any>(operation)));
    } else if (method === 'PUT') {
      return this.http.put(url, data).pipe(catchError(this.handleError<any>(operation)));
    } else if (method === 'DELETE') {
      return this.http.delete(url).pipe(catchError(this.handleError<any>(operation)));
    }
  }

 // Error msg

 errorCount = 0
 public handleError<T>(operation, result?: T) {
  return (error: any): Observable<T> => {
     if (error.status === 500 ) {
      this.util.stopLoader()
      if (operation != undefined) {
        Swal.fire(operation);
      }
      throw error;
    }else if (error.status === 0 ) {
      this.util.stopLoader()
      throw error;
    }else if (error.status === 400 || error.status === 401 ) {
      this.util.stopLoader()
      throw error;
    }else if (error.status === 303 ) {
      this.util.stopLoader()
      throw error;
    }
    return of(result as T);
  };
 }

 public handleErrorOld<T>(operation = 'operation', result?: T) {



  return (error: any): Observable<T> => {
    if (error.status === 0) {
      if (this.errorCount === 0) {
        Swal.fire('Server is not reachable. Please contact system admin');
        this.errorCount++;
      }
    } else if (error.status === 401) {
      if (this.errorCount === 0) {
        Swal.fire('Timeout error. Please try again');
        this.errorCount++;
        return;
      }
    } else if (error.status === 500 || error.status === 501) {
      if (this.errorCount === 0) {
        Swal.fire('Internal Server Error. Please try again');
        this.errorCount++;
        return;
      }
    } else if (error.status === 400) {
      if (this.errorCount === 0) {
        Swal.fire('Bad request');
        localStorage.clear();
      }
    }
    return of(result as T);
  };
 }

 handleError1(error: HttpErrorResponse){
  return throwError(error);
  }
 }
